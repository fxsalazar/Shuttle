Index: app/src/main/java/com/simplecity/amp_library/playback/CastPlayback.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/simplecity/amp_library/playback/CastPlayback.java	(date 1525162643000)
+++ app/src/main/java/com/simplecity/amp_library/playback/CastPlayback.java	(date 1525162643000)
@@ -0,0 +1,136 @@
+package com.simplecity.amp_library.playback;
+
+import android.util.Log;
+
+import com.google.android.libraries.cast.companionlibrary.cast.exceptions.CastException;
+import com.google.android.libraries.cast.companionlibrary.cast.exceptions.NoConnectionException;
+import com.google.android.libraries.cast.companionlibrary.cast.exceptions.TransientNetworkDisconnectionException;
+
+public class CastPlayback implements Playback {
+
+    private static final String TAG = "CastPlayback";
+
+    @interface PlaybackState {
+        int PLAYING = 0;
+        int PAUSED = 1;
+        int STOPPED = 2;
+    }
+
+    private ChromecastManager chromecastManager;
+
+    private QueueManager queueManager;
+
+    @PlaybackState
+    private int playbackState = PlaybackState.STOPPED;
+
+    public CastPlayback(ChromecastManager chromecastManager, QueueManager queueManager) {
+        this.chromecastManager = chromecastManager;
+        this.queueManager = queueManager;
+    }
+
+    @Override
+    public boolean open(String path) {
+        // No-op
+        return true;
+    }
+
+    @Override
+    public void setNextTrack(String path) {
+        // No-op
+    }
+
+    @Override
+    public boolean play() {
+        switch (playbackState) {
+            case PlaybackState.STOPPED: {
+                try {
+                    chromecastManager.castManager.checkConnectivity();
+                    chromecastManager.prepareChromeCastLoad(queueManager.getCurrentSong(), 0, true);
+                    playbackState = PlaybackState.PLAYING;
+                    return true;
+                } catch (TransientNetworkDisconnectionException | NoConnectionException e) {
+                    Log.e(TAG, "Play() called & failed. State: Stopped " + e.toString());
+                    playbackState = PlaybackState.STOPPED;
+                }
+                break;
+            }
+            case PlaybackState.PAUSED: {
+                try {
+                    chromecastManager.castManager.checkConnectivity();
+                    chromecastManager.castManager.play();
+                    playbackState = PlaybackState.PLAYING;
+                    return true;
+                } catch (TransientNetworkDisconnectionException | NoConnectionException | CastException e) {
+                    Log.e(TAG, "Play() called & failed. State: Paused " + e.toString());
+                    playbackState = PlaybackState.PAUSED;
+                }
+                break;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public void pause() {
+        try {
+            chromecastManager.castManager.pause();
+            playbackState = PlaybackState.PAUSED;
+        } catch (Exception e) {
+            Log.e(TAG, e.toString());
+        }
+    }
+
+    @Override
+    public void stop() {
+        playbackState = PlaybackState.STOPPED;
+    }
+
+    @Override
+    public void seek(long position) {
+        try {
+            chromecastManager.castManager.seek((int) position);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void setVolume(float volume) {
+        // No-op
+    }
+
+    @Override
+    public long getPosition() {
+        try {
+            return (int) chromecastManager.castManager.getCurrentMediaPosition();
+        } catch (Exception e) {
+            Log.e(TAG, e.toString());
+        }
+        return 0;
+    }
+
+    @Override
+    public boolean isPlaying() {
+        return playbackState == PlaybackState.PLAYING;
+    }
+
+    @Override
+    public int getAudioSessionId() {
+        return 0;
+    }
+
+    @Override
+    public void release() {
+        chromecastManager.release();
+    }
+
+    @Override
+    public void setCallbacks(Callbacks callbacks) {
+
+    }
+
+    void setPlaybackState(@PlaybackState int playbackState) {
+        this.playbackState = playbackState;
+    }
+
+}
Index: app/src/main/java/com/simplecity/amp_library/playback/ChromecastManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.simplecity.amp_library.playback;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.util.Log;\nimport com.bumptech.glide.Glide;\nimport com.bumptech.glide.request.animation.GlideAnimation;\nimport com.bumptech.glide.request.target.SimpleTarget;\nimport com.google.android.gms.cast.ApplicationMetadata;\nimport com.google.android.gms.cast.MediaInfo;\nimport com.google.android.gms.cast.MediaMetadata;\nimport com.google.android.gms.cast.MediaStatus;\nimport com.google.android.gms.common.images.WebImage;\nimport com.google.android.libraries.cast.companionlibrary.cast.VideoCastManager;\nimport com.google.android.libraries.cast.companionlibrary.cast.callbacks.VideoCastConsumerImpl;\nimport com.google.android.libraries.cast.companionlibrary.cast.exceptions.CastException;\nimport com.google.android.libraries.cast.companionlibrary.cast.exceptions.NoConnectionException;\nimport com.google.android.libraries.cast.companionlibrary.cast.exceptions.TransientNetworkDisconnectionException;\nimport com.simplecity.amp_library.glide.utils.GlideUtils;\nimport com.simplecity.amp_library.http.HttpServer;\nimport com.simplecity.amp_library.model.Song;\nimport com.simplecity.amp_library.utils.LogUtils;\nimport com.simplecity.amp_library.utils.PlaceholderProvider;\nimport com.simplecity.amp_library.utils.ShuttleUtils;\nimport io.reactivex.Completable;\nimport io.reactivex.android.schedulers.AndroidSchedulers;\nimport io.reactivex.disposables.CompositeDisposable;\nimport io.reactivex.schedulers.Schedulers;\n\nimport java.io.ByteArrayOutputStream;\n\nclass ChromecastManager {\n\n    private static final String TAG = \"ChromecastManager\";\n\n    private Context context;\n\n    private PlaybackManager playbackManager;\n\n    VideoCastManager castManager;\n\n    private VideoCastConsumerImpl castConsumer;\n\n    private int castMediaStatus = -1;\n\n    private CompositeDisposable disposables = new CompositeDisposable();\n\n    private QueueManager queueManager;\n\n    ChromecastManager(Context context, QueueManager queueManager, PlaybackManager playbackManager) {\n        this.context = context;\n        this.queueManager = queueManager;\n        this.playbackManager = playbackManager;\n    }\n\n    void init() {\n        if (ShuttleUtils.isUpgraded()) {\n            castManager = VideoCastManager.getInstance();\n            setupCastListener();\n            castManager.addVideoCastConsumer(castConsumer);\n        }\n\n        if (castManager != null && castManager.isConnected()) {\n            updatePlaybackLocation(PlaybackManager.PlaybackLocation.REMOTE);\n        } else {\n            updatePlaybackLocation(PlaybackManager.PlaybackLocation.LOCAL);\n        }\n    }\n\n    void release() {\n        disposables.clear();\n\n        if (castManager != null) {\n            try {\n                castManager.stop();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            castManager.removeVideoCastConsumer(castConsumer);\n        }\n    }\n\n    private void updatePlaybackLocation(@PlaybackManager.PlaybackLocation int location) {\n\n        // If the location has changed and it's no longer ChromeCast\n        if (location == PlaybackManager.PlaybackLocation.LOCAL && location != playbackManager.getPlaybackLocation()) {\n            try {\n                if (castManager != null && castManager.isConnected()) {\n                    playbackManager.seekTo(castManager.getCurrentMediaPosition());\n                    castManager.stop();\n                }\n            } catch (CastException | NoConnectionException | TransientNetworkDisconnectionException | IllegalStateException e) {\n                Log.e(TAG, \"updatePlaybackLocation error: \" + e);\n            }\n        }\n\n        playbackManager.setPlaybackLocation(location);\n    }\n\n    private void loadRemoteMedia(@NonNull Song song, @NonNull MediaInfo selectedMedia, int position, boolean autoPlay, @Nullable Bitmap bitmap, Drawable errorDrawable) {\n        disposables.add(Completable.fromAction(() -> {\n                    HttpServer.getInstance().serveAudio(song.path);\n\n                    ByteArrayOutputStream stream = new ByteArrayOutputStream();\n\n                    if (bitmap == null) {\n                        GlideUtils.drawableToBitmap(errorDrawable).compress(Bitmap.CompressFormat.JPEG, 80, stream);\n                    } else {\n                        bitmap.compress(Bitmap.CompressFormat.JPEG, 80, stream);\n                    }\n\n                    HttpServer.getInstance().serveImage(stream.toByteArray());\n                })\n                        .subscribeOn(Schedulers.io())\n                        .observeOn(AndroidSchedulers.mainThread())\n                        .subscribe(() -> {\n                            try {\n                                castManager.loadMedia(selectedMedia, autoPlay, position);\n                            } catch (Exception e) {\n                                Log.e(TAG, \"Failed to load media. \" + e.toString());\n                            }\n                        }, throwable -> LogUtils.logException(TAG, \"Error loading remote media\", throwable))\n        );\n    }\n\n    void prepareChromeCastLoad(@NonNull Song song, int position, boolean autoPlay) {\n\n        MediaMetadata metadata = new MediaMetadata(MediaMetadata.MEDIA_TYPE_MUSIC_TRACK);\n        metadata.putString(MediaMetadata.KEY_ALBUM_ARTIST, song.albumArtistName);\n        metadata.putString(MediaMetadata.KEY_ALBUM_TITLE, song.albumName);\n        metadata.putString(MediaMetadata.KEY_TITLE, song.name);\n        metadata.addImage(new WebImage(Uri.parse(\"http://\" + ShuttleUtils.getIpAddr() + \":5000\" + \"/image/\" + song.id)));\n\n        MediaInfo selectedMedia = new MediaInfo.Builder(\"http://\" + ShuttleUtils.getIpAddr() + \":5000\" + \"/audio/\" + song.id)\n                .setStreamType(MediaInfo.STREAM_TYPE_BUFFERED)\n                .setContentType(\"audio/*\")\n                .setMetadata(metadata)\n                .build();\n\n        disposables.add(Completable.defer(() -> Completable.fromAction(() ->\n                Glide.with(context)\n                        .load(song)\n                        .asBitmap()\n                        .override(1024, 1024)\n                        .placeholder(PlaceholderProvider.getInstance().getPlaceHolderDrawable(song.name, true))\n                        .into(new SimpleTarget<Bitmap>() {\n                            @Override\n                            public void onResourceReady(Bitmap resource, GlideAnimation<? super Bitmap> glideAnimation) {\n                                loadRemoteMedia(song, selectedMedia, position, autoPlay, resource, null);\n                            }\n\n                            @Override\n                            public void onLoadFailed(Exception e, Drawable errorDrawable) {\n                                super.onLoadFailed(e, errorDrawable);\n                                loadRemoteMedia(song, selectedMedia, position, autoPlay, null, errorDrawable);\n                            }\n                        })))\n                .subscribeOn(AndroidSchedulers.mainThread())\n                .subscribe());\n    }\n\n    private void setupCastListener() {\n\n        castConsumer = new VideoCastConsumerImpl() {\n\n            @Override\n            public void onApplicationConnected(ApplicationMetadata appMetadata, String sessionId, boolean wasLaunched) {\n\n                Log.d(TAG, \"onApplicationLaunched()\");\n\n                HttpServer.getInstance().start();\n\n                boolean wasPlaying = playbackManager.getIsSupposedToBePlaying();\n\n                // If music is playing on the phone, pause it\n                if (playbackManager.getPlaybackLocation() == PlaybackManager.PlaybackLocation.LOCAL && wasPlaying) {\n                    playbackManager.pause();\n                }\n\n                // Try to play from the same position, but on the ChromeCast\n                if (queueManager.getCurrentSong() != null) {\n                    prepareChromeCastLoad(queueManager.getCurrentSong(), (int) playbackManager.getSeekPosition(), wasPlaying);\n                    if (wasPlaying) {\n                        playbackManager.setPlaybackState(PlaybackManager.PlaybackState.PLAYING);\n                    } else {\n                        playbackManager.setPlaybackState(PlaybackManager.PlaybackState.PAUSED);\n                    }\n                }\n\n                updatePlaybackLocation(PlaybackManager.PlaybackLocation.REMOTE);\n            }\n\n            @Override\n            public void onApplicationDisconnected(int errorCode) {\n                Log.d(TAG, \"onApplicationDisconnected() is reached with errorCode: \" + errorCode);\n                playbackManager.setIsSupposedToBePlaying(false, true);\n                playbackManager.setPlaybackState(PlaybackManager.PlaybackState.STOPPED);\n                updatePlaybackLocation(PlaybackManager.PlaybackLocation.LOCAL);\n\n                HttpServer.getInstance().stop();\n            }\n\n            @Override\n            public void onDisconnected() {\n                Log.d(TAG, \"onDisconnected() is reached\");\n                playbackManager.setIsSupposedToBePlaying(false, true);\n                playbackManager.setPlaybackState(PlaybackManager.PlaybackState.STOPPED);\n                updatePlaybackLocation(PlaybackManager.PlaybackLocation.LOCAL);\n\n                HttpServer.getInstance().stop();\n            }\n\n            @Override\n            public void onRemoteMediaPlayerStatusUpdated() {\n                // Only send a track finished message if the state has changed..\n                if (castManager.getPlaybackStatus() != castMediaStatus) {\n                    if (castManager.getPlaybackStatus() == MediaStatus.PLAYER_STATE_IDLE && castManager.getIdleReason() == MediaStatus.IDLE_REASON_FINISHED) {\n                        playbackManager.notifyTrackEnded();\n                    }\n                }\n                castMediaStatus = castManager.getPlaybackStatus();\n            }\n        };\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/simplecity/amp_library/playback/ChromecastManager.java	(revision e0764bcc340e8fa6a5427d9224c7e5b3dc656f05)
+++ app/src/main/java/com/simplecity/amp_library/playback/ChromecastManager.java	(date 1525084675000)
@@ -7,6 +7,7 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.request.animation.GlideAnimation;
 import com.bumptech.glide.request.target.SimpleTarget;
@@ -26,13 +27,14 @@
 import com.simplecity.amp_library.utils.LogUtils;
 import com.simplecity.amp_library.utils.PlaceholderProvider;
 import com.simplecity.amp_library.utils.ShuttleUtils;
+
+import java.io.ByteArrayOutputStream;
+
 import io.reactivex.Completable;
 import io.reactivex.android.schedulers.AndroidSchedulers;
 import io.reactivex.disposables.CompositeDisposable;
 import io.reactivex.schedulers.Schedulers;
 
-import java.io.ByteArrayOutputStream;
-
 class ChromecastManager {
 
     private static final String TAG = "ChromecastManager";
@@ -185,9 +187,9 @@
                 if (queueManager.getCurrentSong() != null) {
                     prepareChromeCastLoad(queueManager.getCurrentSong(), (int) playbackManager.getSeekPosition(), wasPlaying);
                     if (wasPlaying) {
-                        playbackManager.setPlaybackState(PlaybackManager.PlaybackState.PLAYING);
+                        playbackManager.setPlaybackState(CastPlayback.PlaybackState.PLAYING);
                     } else {
-                        playbackManager.setPlaybackState(PlaybackManager.PlaybackState.PAUSED);
+                        playbackManager.setPlaybackState(CastPlayback.PlaybackState.PAUSED);
                     }
                 }
 
@@ -198,7 +200,7 @@
             public void onApplicationDisconnected(int errorCode) {
                 Log.d(TAG, "onApplicationDisconnected() is reached with errorCode: " + errorCode);
                 playbackManager.setIsSupposedToBePlaying(false, true);
-                playbackManager.setPlaybackState(PlaybackManager.PlaybackState.STOPPED);
+                playbackManager.setPlaybackState(CastPlayback.PlaybackState.STOPPED);
                 updatePlaybackLocation(PlaybackManager.PlaybackLocation.LOCAL);
 
                 HttpServer.getInstance().stop();
@@ -208,7 +210,7 @@
             public void onDisconnected() {
                 Log.d(TAG, "onDisconnected() is reached");
                 playbackManager.setIsSupposedToBePlaying(false, true);
-                playbackManager.setPlaybackState(PlaybackManager.PlaybackState.STOPPED);
+                playbackManager.setPlaybackState(CastPlayback.PlaybackState.STOPPED);
                 updatePlaybackLocation(PlaybackManager.PlaybackLocation.LOCAL);
 
                 HttpServer.getInstance().stop();
Index: app/src/main/java/com/simplecity/amp_library/playback/LocalPlayback.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/simplecity/amp_library/playback/LocalPlayback.java	(date 1525083370000)
+++ app/src/main/java/com/simplecity/amp_library/playback/LocalPlayback.java	(date 1525083370000)
@@ -0,0 +1,114 @@
+package com.simplecity.amp_library.playback;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.crashlytics.android.core.CrashlyticsCore;
+
+public class LocalPlayback implements Playback {
+
+    private static final String TAG = "LocalPlayback";
+
+    private boolean isSupposedToBePlaying;
+
+    @NonNull
+    private MultiPlayer multiPlayer;
+
+    public LocalPlayback(Context context) {
+        this.multiPlayer = new MultiPlayer(context);
+    }
+
+    @Override
+    public boolean open(String path) {
+        multiPlayer.setDataSource(path);
+        return multiPlayer.isInitialized();
+    }
+
+    @Override
+    public void setNextTrack(@Nullable String path) {
+        try {
+            multiPlayer.setNextDataSource(path);
+        } catch (Exception e) {
+            Log.e(TAG, "Error: " + e.getMessage());
+            CrashlyticsCore.getInstance().log("setNextTrack() with id failed. error: " + e.getLocalizedMessage());
+        }
+    }
+
+    @Override
+    public boolean play() {
+        if (multiPlayer.start()) {
+            isSupposedToBePlaying = true;
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void pause() {
+        multiPlayer.pause();
+        isSupposedToBePlaying = false;
+    }
+
+    @Override
+    public void stop() {
+        multiPlayer.stop();
+        isSupposedToBePlaying = false;
+    }
+
+    @Override
+    public void seek(long position) {
+        multiPlayer.seekTo(position);
+    }
+
+    @Override
+    public void setVolume(float volume) {
+        multiPlayer.setVolume(volume);
+    }
+
+    @Override
+    public long getPosition() {
+        return multiPlayer.getPosition();
+    }
+
+    @Override
+    public boolean isPlaying() {
+        return multiPlayer.isInitialized() && isSupposedToBePlaying;
+    }
+
+    @Override
+    public int getAudioSessionId() {
+        return multiPlayer.getAudioSessionId();
+    }
+
+    @Override
+    public void release() {
+        multiPlayer.release();
+        multiPlayer.releaseWakelock();
+    }
+
+    @Override
+    public void setCallbacks(Callbacks callbacks) {
+        multiPlayer.setCallbacks(new Callbacks() {
+            @Override
+            public void trackEnded(Playback playback) {
+                callbacks.trackEnded(LocalPlayback.this);
+            }
+
+            @Override
+            public void trackWentToNext(Playback playback) {
+                callbacks.trackWentToNext(LocalPlayback.this);
+            }
+
+            @Override
+            public void onError(Playback playback, String error) {
+                callbacks.onError(LocalPlayback.this, error);
+            }
+        });
+    }
+
+    void releaseWakeLock() {
+        multiPlayer.releaseWakelock();
+    }
+}
Index: app/src/main/java/com/simplecity/amp_library/playback/MediaPlayerHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.simplecity.amp_library.playback;\n\nimport android.media.AudioManager;\nimport android.os.Handler;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.util.Log;\nimport com.simplecity.amp_library.playback.constants.InternalIntents;\nimport com.simplecity.amp_library.playback.constants.PlayerHandler;\n\nimport java.lang.ref.WeakReference;\n\nfinal class MediaPlayerHandler extends Handler {\n\n    private static final String TAG = \"MediaPlayerHandler\";\n\n    private final WeakReference<PlaybackManager> playbackManagerWeakReference;\n    private final WeakReference<QueueManager> queueManagerWeakReference;\n\n    private float currentVolume = 1.0f;\n\n    MediaPlayerHandler(PlaybackManager playbackManager, QueueManager queueManager, Looper looper) {\n        super(looper);\n        this.playbackManagerWeakReference = new WeakReference<>(playbackManager);\n        this.queueManagerWeakReference = new WeakReference<>(queueManager);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n        PlaybackManager playbackManager = playbackManagerWeakReference.get();\n        QueueManager queueManager = queueManagerWeakReference.get();\n        if (playbackManager == null || queueManager == null) {\n            return;\n        }\n\n        switch (msg.what) {\n            case PlayerHandler.FADE_DOWN:\n                currentVolume -= .05f;\n                if (currentVolume > .2f) {\n                    sendEmptyMessageDelayed(PlayerHandler.FADE_DOWN, 10);\n                } else {\n                    currentVolume = .2f;\n                }\n                playbackManager.setVolume(currentVolume);\n                break;\n            case PlayerHandler.FADE_UP:\n                currentVolume += .01f;\n                if (currentVolume < 1.0f) {\n                    sendEmptyMessageDelayed(PlayerHandler.FADE_UP, 10);\n                } else {\n                    currentVolume = 1.0f;\n                }\n                playbackManager.setVolume(currentVolume);\n                break;\n            case PlayerHandler.SERVER_DIED:\n                if (playbackManager.isPlaying()) {\n                    playbackManager.next(true);\n                } else {\n                    playbackManager.openCurrentAndNext();\n                }\n                break;\n            case PlayerHandler.TRACK_WENT_TO_NEXT:\n                playbackManager.notifyChange(InternalIntents.TRACK_ENDING);\n                queueManager.queuePosition = queueManager.nextPlayPos;\n                playbackManager.notifyChange(InternalIntents.META_CHANGED);\n                playbackManager.setNextTrack();\n\n                if (playbackManager.pauseOnTrackFinish) {\n                    playbackManager.pause();\n                    playbackManager.pauseOnTrackFinish = false;\n                }\n                break;\n            case PlayerHandler.TRACK_ENDED:\n                playbackManager.notifyChange(InternalIntents.TRACK_ENDING);\n                if (queueManager.repeatMode == QueueManager.RepeatMode.ONE) {\n                    playbackManager.seekTo(0);\n                    playbackManager.play();\n                } else {\n                    playbackManager.next(false);\n                }\n                break;\n            case PlayerHandler.RELEASE_WAKELOCK:\n                playbackManager.releaseWakelock();\n                break;\n\n            case PlayerHandler.FOCUS_CHANGE:\n                // This code is here so we can better synchronize it with\n                // the code that handles fade-in\n                switch (msg.arg1) {\n                    case AudioManager.AUDIOFOCUS_LOSS:\n                        if (playbackManager.isPlaying()) {\n                            playbackManager.pausedByTransientLossOfFocus = false;\n                        }\n                        playbackManager.pause();\n                        break;\n                    case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:\n                        removeMessages(PlayerHandler.FADE_UP);\n                        sendEmptyMessage(PlayerHandler.FADE_DOWN);\n                        break;\n                    case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:\n                        if (playbackManager.isPlaying()) {\n                            playbackManager.pausedByTransientLossOfFocus = true;\n                        }\n                        playbackManager.pause();\n                        break;\n                    case AudioManager.AUDIOFOCUS_GAIN:\n                        if (!playbackManager.isPlaying() && playbackManager.pausedByTransientLossOfFocus) {\n                            playbackManager.pausedByTransientLossOfFocus = false;\n                            currentVolume = 0f;\n                            if (playbackManager.player != null) {\n                                playbackManager.player.setVolume(currentVolume);\n                            }\n                            playbackManager.play(); // also queues a fade-in\n                        } else {\n                            removeMessages(PlayerHandler.FADE_DOWN);\n                            sendEmptyMessage(PlayerHandler.FADE_UP);\n                        }\n                        break;\n                    default:\n                        Log.e(TAG, \"Unknown audio focus change code\");\n                }\n                break;\n\n            case PlayerHandler.FADE_DOWN_STOP:\n                currentVolume -= .05f;\n                if (currentVolume > 0f) {\n                    sendEmptyMessageDelayed(PlayerHandler.FADE_DOWN_STOP, 200);\n                } else {\n                    playbackManager.pause();\n                }\n                if (playbackManager.player != null) {\n                    playbackManager.player.setVolume(currentVolume);\n                }\n                break;\n\n            case PlayerHandler.GO_TO_NEXT:\n                playbackManager.next(true);\n                break;\n\n            case PlayerHandler.GO_TO_PREV:\n                playbackManager.previous();\n                break;\n\n            case PlayerHandler.SHUFFLE_ALL:\n                playbackManager.playAutoShuffleList();\n                break;\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/simplecity/amp_library/playback/MediaPlayerHandler.java	(revision e0764bcc340e8fa6a5427d9224c7e5b3dc656f05)
+++ app/src/main/java/com/simplecity/amp_library/playback/MediaPlayerHandler.java	(date 1525162757000)
@@ -5,6 +5,7 @@
 import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
+
 import com.simplecity.amp_library.playback.constants.InternalIntents;
 import com.simplecity.amp_library.playback.constants.PlayerHandler;
 
@@ -107,9 +108,7 @@
                         if (!playbackManager.isPlaying() && playbackManager.pausedByTransientLossOfFocus) {
                             playbackManager.pausedByTransientLossOfFocus = false;
                             currentVolume = 0f;
-                            if (playbackManager.player != null) {
-                                playbackManager.player.setVolume(currentVolume);
-                            }
+                            playbackManager.setVolume(currentVolume);
                             playbackManager.play(); // also queues a fade-in
                         } else {
                             removeMessages(PlayerHandler.FADE_DOWN);
@@ -128,9 +127,7 @@
                 } else {
                     playbackManager.pause();
                 }
-                if (playbackManager.player != null) {
-                    playbackManager.player.setVolume(currentVolume);
-                }
+                playbackManager.setVolume(currentVolume);
                 break;
 
             case PlayerHandler.GO_TO_NEXT:
Index: app/src/main/java/com/simplecity/amp_library/playback/MultiPlayer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.simplecity.amp_library.playback;\n\nimport android.content.Context;\nimport android.media.AudioAttributes;\nimport android.media.AudioManager;\nimport android.media.MediaPlayer;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.PowerManager;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport com.crashlytics.android.core.CrashlyticsCore;\nimport com.simplecity.amp_library.playback.constants.PlayerHandler;\nimport com.simplecity.amp_library.utils.ShuttleUtils;\n\nclass MultiPlayer implements MediaPlayer.OnErrorListener, MediaPlayer.OnCompletionListener {\n\n    private static final String TAG = \"MultiPlayer\";\n\n    private Context context;\n\n    private MediaPlayer currentMediaPlayer = new MediaPlayer();\n\n    private MediaPlayer nextMediaPlayer;\n\n    private Handler handler;\n\n    private boolean isInitialized = false;\n\n    private PowerManager.WakeLock wakeLock;\n\n    MultiPlayer(Context context) {\n        this.context = context.getApplicationContext();\n\n        currentMediaPlayer.setWakeMode(context, PowerManager.PARTIAL_WAKE_LOCK);\n\n        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);\n        if (powerManager != null) {\n            wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, getClass().getName());\n        }\n        wakeLock.setReferenceCounted(false);\n    }\n\n    void setDataSource(final String path) {\n        isInitialized = setDataSourceImpl(currentMediaPlayer, path);\n        if (isInitialized) {\n            setNextDataSource(null);\n        }\n    }\n\n    private boolean setDataSourceImpl(final MediaPlayer mediaPlayer, final String path) {\n        if (TextUtils.isEmpty(path) || mediaPlayer == null) {\n            return false;\n        }\n        try {\n            mediaPlayer.reset();\n            mediaPlayer.setOnPreparedListener(null);\n            if (path.startsWith(\"content://\")) {\n                Uri uri = Uri.parse(path);\n                mediaPlayer.setDataSource(context, uri);\n            } else {\n                mediaPlayer.setDataSource(path);\n            }\n            if (ShuttleUtils.hasOreo()) {\n                mediaPlayer.setAudioAttributes(new AudioAttributes.Builder()\n                        .setUsage(AudioAttributes.USAGE_MEDIA)\n                        .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)\n                        .build());\n            } else {\n                mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n            }\n            mediaPlayer.prepare();\n        } catch (final Exception e) {\n            Log.e(TAG, \"setDataSource failed: \" + e.getLocalizedMessage());\n            CrashlyticsCore.getInstance().log(\"setDataSourceImpl failed. Path: [\" + path + \"] error: \" + e.getLocalizedMessage());\n            return false;\n        }\n        mediaPlayer.setOnCompletionListener(this);\n        mediaPlayer.setOnErrorListener(this);\n\n        return true;\n    }\n\n    void setNextDataSource(final String path) {\n        try {\n            currentMediaPlayer.setNextMediaPlayer(null);\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Next media player is current one, continuing\");\n        } catch (IllegalStateException e) {\n            Log.e(TAG, \"Media player not initialized!\");\n            CrashlyticsCore.getInstance().log(\"setNextDataSource failed for. Media player not intitialized.\");\n            return;\n        }\n        if (nextMediaPlayer != null) {\n            nextMediaPlayer.release();\n            nextMediaPlayer = null;\n        }\n        if (TextUtils.isEmpty(path)) {\n            return;\n        }\n        nextMediaPlayer = new MediaPlayer();\n        nextMediaPlayer.setWakeMode(context, PowerManager.PARTIAL_WAKE_LOCK);\n        nextMediaPlayer.setAudioSessionId(getAudioSessionId());\n        if (setDataSourceImpl(nextMediaPlayer, path)) {\n            try {\n                currentMediaPlayer.setNextMediaPlayer(nextMediaPlayer);\n            } catch (Exception e) {\n                Log.e(TAG, \"setNextDataSource failed - failed to call setNextMediaPlayer on currentMediaPlayer. Error: \" + e.getLocalizedMessage());\n                CrashlyticsCore.getInstance().log(\"setNextDataSource failed - failed to call setNextMediaPlayer on currentMediaPlayer. Error: \" + e.getLocalizedMessage());\n                if (nextMediaPlayer != null) {\n                    nextMediaPlayer.release();\n                    nextMediaPlayer = null;\n                }\n            }\n        } else {\n            Log.e(TAG, \"setDataSourceImpl failed for path: [\" + path + \"]. Setting next media player to null\");\n            CrashlyticsCore.getInstance().log(\"setDataSourceImpl failed for path: [\" + path + \"]. Setting next media player to null\");\n            if (nextMediaPlayer != null) {\n                nextMediaPlayer.release();\n                nextMediaPlayer = null;\n            }\n        }\n    }\n\n    boolean isInitialized() {\n        return isInitialized;\n    }\n\n    public void start() {\n        try {\n            currentMediaPlayer.start();\n        } catch (RuntimeException e) {\n            CrashlyticsCore.getInstance().log(\"MusicService.start() failed. Exception: \" + e.toString());\n        }\n    }\n\n    public void stop() {\n        try {\n            currentMediaPlayer.reset();\n        } catch (IllegalStateException e) {\n            Log.e(TAG, \"Error stopping MultiPlayer: \" + e.getLocalizedMessage());\n            CrashlyticsCore.getInstance().log(\"stop() failed. Error: \" + e.getLocalizedMessage());\n        }\n        isInitialized = false;\n    }\n\n    /**\n     * You CANNOT use this player anymore after calling release()\n     */\n    public void release() {\n        stop();\n        currentMediaPlayer.release();\n    }\n\n    public void pause() {\n        try {\n            currentMediaPlayer.pause();\n        } catch (IllegalStateException e) {\n            Log.e(TAG, \"Error pausing MultiPlayer: \" + e.getLocalizedMessage());\n        }\n    }\n\n    public void setHandler(Handler handler) {\n        this.handler = handler;\n    }\n\n    public long getDuration() {\n        try {\n            return currentMediaPlayer.getDuration();\n        } catch (IllegalStateException ignored) {\n            return 0;\n        }\n    }\n\n    public long getPosition() {\n        try {\n            return currentMediaPlayer.getCurrentPosition();\n        } catch (IllegalStateException ignored) {\n            return 0;\n        }\n    }\n\n    void seekTo(long whereto) {\n        try {\n            currentMediaPlayer.seekTo((int) whereto);\n        } catch (IllegalStateException e) {\n            Log.e(TAG, \"Error seeking MultiPlayer: \" + e.getLocalizedMessage());\n        }\n    }\n\n    void setVolume(float vol) {\n        try {\n            currentMediaPlayer.setVolume(vol, vol);\n        } catch (IllegalStateException e) {\n            Log.e(TAG, \"Error setting MultiPlayer volume: \" + e.getLocalizedMessage());\n        }\n    }\n\n    int getAudioSessionId() {\n        int sessionId = 0;\n        try {\n            sessionId = currentMediaPlayer.getAudioSessionId();\n        } catch (IllegalStateException ignored) {\n            //Nothing to do\n        }\n        return sessionId;\n    }\n\n    @Override\n    public boolean onError(final MediaPlayer mp, final int what, final int extra) {\n        switch (what) {\n            case MediaPlayer.MEDIA_ERROR_SERVER_DIED:\n                isInitialized = false;\n                currentMediaPlayer.release();\n                currentMediaPlayer = new MediaPlayer();\n                currentMediaPlayer.setWakeMode(context, PowerManager.PARTIAL_WAKE_LOCK);\n                handler.sendMessageDelayed(handler.obtainMessage(PlayerHandler.SERVER_DIED), 2000);\n                return true;\n            default:\n                break;\n        }\n        return false;\n    }\n\n    @Override\n    public void onCompletion(final MediaPlayer mp) {\n        if (mp == currentMediaPlayer && nextMediaPlayer != null) {\n            currentMediaPlayer.release();\n            currentMediaPlayer = nextMediaPlayer;\n            nextMediaPlayer = null;\n            handler.sendEmptyMessage(PlayerHandler.TRACK_WENT_TO_NEXT);\n        } else {\n            wakeLock.acquire(30000);\n            handler.sendEmptyMessage(PlayerHandler.TRACK_ENDED);\n            handler.sendEmptyMessage(PlayerHandler.RELEASE_WAKELOCK);\n        }\n    }\n\n    public void releaseWakelock() {\n        wakeLock.release();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/simplecity/amp_library/playback/MultiPlayer.java	(revision e0764bcc340e8fa6a5427d9224c7e5b3dc656f05)
+++ app/src/main/java/com/simplecity/amp_library/playback/MultiPlayer.java	(date 1525426232000)
@@ -5,12 +5,12 @@
 import android.media.AudioManager;
 import android.media.MediaPlayer;
 import android.net.Uri;
-import android.os.Handler;
 import android.os.PowerManager;
+import android.support.annotation.NonNull;
 import android.text.TextUtils;
 import android.util.Log;
+
 import com.crashlytics.android.core.CrashlyticsCore;
-import com.simplecity.amp_library.playback.constants.PlayerHandler;
 import com.simplecity.amp_library.utils.ShuttleUtils;
 
 class MultiPlayer implements MediaPlayer.OnErrorListener, MediaPlayer.OnCompletionListener {
@@ -19,16 +19,17 @@
 
     private Context context;
 
+    @NonNull
     private MediaPlayer currentMediaPlayer = new MediaPlayer();
 
     private MediaPlayer nextMediaPlayer;
 
-    private Handler handler;
-
     private boolean isInitialized = false;
 
     private PowerManager.WakeLock wakeLock;
 
+    private LocalPlayback.Callbacks callbacks;
+
     MultiPlayer(Context context) {
         this.context = context.getApplicationContext();
 
@@ -126,12 +127,16 @@
         return isInitialized;
     }
 
-    public void start() {
-        try {
-            currentMediaPlayer.start();
-        } catch (RuntimeException e) {
-            CrashlyticsCore.getInstance().log("MusicService.start() failed. Exception: " + e.toString());
+    public boolean start() {
+        if (isInitialized) {
+            try {
+                currentMediaPlayer.start();
+                return true;
+            } catch (RuntimeException e) {
+                CrashlyticsCore.getInstance().log("MusicService.start() failed. Exception: " + e.toString());
+            }
         }
+        return false;
     }
 
     public void stop() {
@@ -153,46 +158,52 @@
     }
 
     public void pause() {
-        try {
-            currentMediaPlayer.pause();
-        } catch (IllegalStateException e) {
-            Log.e(TAG, "Error pausing MultiPlayer: " + e.getLocalizedMessage());
-        }
-    }
-
-    public void setHandler(Handler handler) {
-        this.handler = handler;
+        if (isInitialized) {
+            try {
+                currentMediaPlayer.pause();
+            } catch (IllegalStateException e) {
+                Log.e(TAG, "Error pausing MultiPlayer: " + e.getLocalizedMessage());
+            }
+        }
     }
 
     public long getDuration() {
-        try {
-            return currentMediaPlayer.getDuration();
-        } catch (IllegalStateException ignored) {
-            return 0;
-        }
+        if (isInitialized) {
+            try {
+                return currentMediaPlayer.getDuration();
+            } catch (IllegalStateException ignored) {
+            }
+        }
+        return 0;
     }
 
     public long getPosition() {
-        try {
-            return currentMediaPlayer.getCurrentPosition();
-        } catch (IllegalStateException ignored) {
-            return 0;
-        }
+        if (isInitialized) {
+            try {
+                return currentMediaPlayer.getCurrentPosition();
+            } catch (IllegalStateException ignored) {
+            }
+        }
+        return 0;
     }
 
     void seekTo(long whereto) {
-        try {
-            currentMediaPlayer.seekTo((int) whereto);
-        } catch (IllegalStateException e) {
-            Log.e(TAG, "Error seeking MultiPlayer: " + e.getLocalizedMessage());
+        if (isInitialized) {
+            try {
+                currentMediaPlayer.seekTo((int) whereto);
+            } catch (IllegalStateException e) {
+                Log.e(TAG, "Error seeking MultiPlayer: " + e.getLocalizedMessage());
+            }
         }
     }
 
     void setVolume(float vol) {
-        try {
-            currentMediaPlayer.setVolume(vol, vol);
-        } catch (IllegalStateException e) {
-            Log.e(TAG, "Error setting MultiPlayer volume: " + e.getLocalizedMessage());
+        if (isInitialized) {
+            try {
+                currentMediaPlayer.setVolume(vol, vol);
+            } catch (IllegalStateException e) {
+                Log.e(TAG, "Error setting MultiPlayer volume: " + e.getLocalizedMessage());
+            }
         }
     }
 
@@ -207,14 +218,14 @@
     }
 
     @Override
-    public boolean onError(final MediaPlayer mp, final int what, final int extra) {
+    public boolean onError(MediaPlayer mediaPlayer, int what, final int extra) {
         switch (what) {
             case MediaPlayer.MEDIA_ERROR_SERVER_DIED:
                 isInitialized = false;
                 currentMediaPlayer.release();
                 currentMediaPlayer = new MediaPlayer();
                 currentMediaPlayer.setWakeMode(context, PowerManager.PARTIAL_WAKE_LOCK);
-                handler.sendMessageDelayed(handler.obtainMessage(PlayerHandler.SERVER_DIED), 2000);
+                callbacks.onError(null, "Server died");
                 return true;
             default:
                 break;
@@ -223,20 +234,23 @@
     }
 
     @Override
-    public void onCompletion(final MediaPlayer mp) {
-        if (mp == currentMediaPlayer && nextMediaPlayer != null) {
+    public void onCompletion(MediaPlayer mediaPlayer) {
+        if (mediaPlayer == currentMediaPlayer && nextMediaPlayer != null) {
             currentMediaPlayer.release();
             currentMediaPlayer = nextMediaPlayer;
             nextMediaPlayer = null;
-            handler.sendEmptyMessage(PlayerHandler.TRACK_WENT_TO_NEXT);
+            callbacks.trackWentToNext(null);
         } else {
             wakeLock.acquire(30000);
-            handler.sendEmptyMessage(PlayerHandler.TRACK_ENDED);
-            handler.sendEmptyMessage(PlayerHandler.RELEASE_WAKELOCK);
+            callbacks.trackEnded(null);
         }
     }
 
     public void releaseWakelock() {
         wakeLock.release();
     }
+
+    public void setCallbacks(LocalPlayback.Callbacks callbacks) {
+        this.callbacks = callbacks;
+    }
 }
Index: app/src/main/java/com/simplecity/amp_library/playback/Playback.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/simplecity/amp_library/playback/Playback.java	(date 1525083357000)
+++ app/src/main/java/com/simplecity/amp_library/playback/Playback.java	(date 1525083357000)
@@ -0,0 +1,45 @@
+package com.simplecity.amp_library.playback;
+
+import android.support.annotation.Nullable;
+
+public interface Playback {
+
+    /**
+     * Open/prepare the passed in path for playback
+     *
+     * @return true if the item at the specified path was successfully opened
+     */
+    boolean open(String path);
+
+    void setNextTrack(@Nullable String path);
+
+    boolean play();
+
+    void pause();
+
+    void stop();
+
+    void seek(long position);
+
+    void setVolume(float volume);
+
+    long getPosition();
+
+    boolean isPlaying();
+
+    int getAudioSessionId();
+
+    void release();
+
+    void setCallbacks(Callbacks callbacks);
+
+    interface Callbacks {
+
+        void trackEnded(Playback playback);
+
+        void trackWentToNext(Playback playback);
+
+        void onError(Playback playback, String error);
+    }
+
+}
Index: app/src/main/java/com/simplecity/amp_library/playback/PlaybackManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.simplecity.amp_library.playback;\n\nimport android.Manifest;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.sqlite.SQLiteException;\nimport android.media.AudioAttributes;\nimport android.media.AudioFocusRequest;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.HandlerThread;\nimport android.provider.MediaStore;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v4.media.session.MediaSessionCompat;\nimport android.util.Log;\nimport com.annimon.stream.function.Predicate;\nimport com.crashlytics.android.core.CrashlyticsCore;\nimport com.google.android.libraries.cast.companionlibrary.cast.exceptions.CastException;\nimport com.google.android.libraries.cast.companionlibrary.cast.exceptions.NoConnectionException;\nimport com.google.android.libraries.cast.companionlibrary.cast.exceptions.TransientNetworkDisconnectionException;\nimport com.simplecity.amp_library.http.HttpServer;\nimport com.simplecity.amp_library.model.Song;\nimport com.simplecity.amp_library.playback.constants.InternalIntents;\nimport com.simplecity.amp_library.playback.constants.PlayerHandler;\nimport com.simplecity.amp_library.services.Equalizer;\nimport com.simplecity.amp_library.utils.*;\nimport io.reactivex.disposables.CompositeDisposable;\nimport io.reactivex.functions.Action;\nimport io.reactivex.schedulers.Schedulers;\n\nimport java.util.List;\n\npublic class PlaybackManager {\n\n    private static final String TAG = \"PlaybackManager\";\n\n    @interface PlaybackLocation {\n        int REMOTE = 0;\n        int LOCAL = 1;\n    }\n\n    @interface PlaybackState {\n        int PLAYING = 0;\n        int PAUSED = 1;\n        int STOPPED = 2;\n    }\n\n    private Context context;\n\n    private HandlerThread handlerThread;\n\n    private QueueManager queueManager;\n\n    private ChromecastManager chromecastManager;\n\n    private MediaSessionManager mediaSessionManager;\n\n    private boolean playOnQueueLoad;\n\n    @PlaybackState\n    private int playbackState;\n\n    private Equalizer equalizer;\n\n    @PlaybackLocation\n    private int playbackLocation = PlaybackLocation.LOCAL;\n\n    @Nullable\n    private AudioFocusRequest audioFocusRequest;\n\n    @Nullable\n    MultiPlayer player;\n\n    private AudioManager audioManager;\n\n    private int openFailedCounter = 0;\n\n    private boolean isSupposedToBePlaying = false;\n\n    private long lastPlayedTime;\n\n    private MediaPlayerHandler playerHandler;\n\n    // Used to track what type of audio focus loss caused the playback to pause\n    boolean pausedByTransientLossOfFocus = false;\n\n    private CompositeDisposable disposables = new CompositeDisposable();\n\n    boolean pauseOnTrackFinish = false;\n\n    private MusicService.Callbacks musicServiceCallbacks;\n\n    private AudioManager.OnAudioFocusChangeListener audioFocusListener = new AudioManager.OnAudioFocusChangeListener() {\n        public void onAudioFocusChange(final int focusChange) {\n            playerHandler.obtainMessage(PlayerHandler.FOCUS_CHANGE, focusChange, 0).sendToTarget();\n        }\n    };\n\n    PlaybackManager(Context context, QueueManager queueManager, MusicService.Callbacks musicServiceCallbacks) {\n\n        this.context = context.getApplicationContext();\n\n        this.queueManager = queueManager;\n\n        this.musicServiceCallbacks = musicServiceCallbacks;\n\n        mediaSessionManager = new MediaSessionManager(context, queueManager, this, musicServiceCallbacks);\n\n        chromecastManager = new ChromecastManager(context, queueManager, this);\n\n        // Start up the thread running the service. Note that we create a separate thread because the service normally runs in the process's\n        // main thread, which we don't want to block. We also make it background priority so CPU-intensive work will not disrupt the UI.\n        handlerThread = new HandlerThread(\"MusicPlayerHandler\", android.os.Process.THREAD_PRIORITY_BACKGROUND);\n        handlerThread.start();\n\n        playerHandler = new MediaPlayerHandler(this, queueManager, handlerThread.getLooper());\n\n        playbackState = PlaybackState.STOPPED;\n\n        player = new MultiPlayer(context);\n        player.setHandler(playerHandler);\n\n        equalizer = new Equalizer(context);\n\n        audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);\n\n        chromecastManager.init();\n\n        disposables.add(SleepTimer.getInstance().getCurrentTimeObservable()\n                .subscribe(remainingTime -> {\n                    if (remainingTime == 0) {\n                        if (SleepTimer.getInstance().playToEnd) {\n                            pauseOnTrackFinish = true;\n                        } else {\n                            playerHandler.sendEmptyMessage(PlayerHandler.FADE_DOWN_STOP);\n                        }\n                    }\n                }, throwable -> LogUtils.logException(TAG, \"Error consuming SleepTimer observable\", throwable)));\n    }\n\n    public void setPausedByTransientLossOfFocus(boolean pausedByTransientLossOfFocus) {\n        this.pausedByTransientLossOfFocus = pausedByTransientLossOfFocus;\n    }\n\n    public void setQueuePosition(int position) {\n        stop(false);\n        queueManager.queuePosition = position;\n        openCurrentAndNext();\n        play();\n        notifyChange(InternalIntents.META_CHANGED);\n    }\n\n    public void clearQueue() {\n        stop(true);\n        queueManager.clearQueue();\n    }\n\n    public void reloadQueue() {\n        if (ContextCompat.checkSelfPermission(context, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n        queueManager.reloadQueue(this::reloadComplete,\n                () -> {\n                    setOpenFailedCounter(20);\n                    openCurrentAndNext();\n                },\n                seekPos -> {\n                    if (queueManager.getCurrentSong() != null) {\n                        seekTo(seekPos < queueManager.getCurrentSong().duration ? seekPos : 0);\n                    }\n                });\n    }\n\n    public void removeSongs(List<Song> songs) {\n        queueManager.removeSongs(songs, () -> stop(true), () -> {\n            final boolean wasPlaying = isPlaying();\n            stop(false);\n            openCurrentAndNext();\n            if (wasPlaying) {\n                play();\n            }\n        });\n    }\n\n    public void removeSong(int position) {\n        queueManager.removeSong(position, () -> stop(true), () -> {\n            final boolean wasPlaying = isPlaying();\n            stop(false);\n            openCurrentAndNext();\n            if (wasPlaying) {\n                play();\n            }\n        });\n    }\n\n    public void moveQueueItem(int from, int to) {\n        queueManager.moveQueueItem(from, to);\n    }\n\n    void notifyChange(String what) {\n        musicServiceCallbacks.notifyChange(what);\n    }\n\n    public void setVolume(float volume) {\n        if (player != null) {\n            player.setVolume(volume);\n        }\n    }\n\n    public void playAutoShuffleList() {\n        if (ContextCompat.checkSelfPermission(context, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {\n            disposables.add(DataManager.getInstance().getSongsRelay()\n                    .firstOrError()\n                    .subscribeOn(Schedulers.io())\n                    .subscribe(songs -> {\n                        queueManager.playlist = songs;\n                        queueManager.queuePosition = -1;\n                        queueManager.makeShuffleList();\n                        queueManager.setShuffleMode(QueueManager.ShuffleMode.ON);\n                        notifyChange(InternalIntents.QUEUE_CHANGED);\n                        queueManager.queuePosition = 0;\n                        openCurrentAndNext();\n                        play();\n                        notifyChange(InternalIntents.META_CHANGED);\n                        queueManager.saveQueue(false);\n                    }, error -> LogUtils.logException(TAG, \"Error playing auto shuffle list\", error)));\n\n        } else {\n            queueManager.shuffleMode = QueueManager.ShuffleMode.OFF;\n            queueManager.saveQueue(false);\n        }\n    }\n\n    void notifyTrackEnded() {\n        playerHandler.sendEmptyMessage(PlayerHandler.TRACK_ENDED);\n    }\n\n    private void reloadComplete() {\n        if (playOnQueueLoad) {\n            play();\n            playOnQueueLoad = false;\n        }\n    }\n\n    public MediaSessionCompat.Token getMediaSessionToken() {\n        return mediaSessionManager.getSessionToken();\n    }\n\n    public boolean hasTrackEndedMessage() {\n        return playerHandler.hasMessages(PlayerHandler.TRACK_ENDED);\n    }\n\n    public void closeEqualizerSessions(boolean internal, int audioSessionId) {\n        equalizer.closeEqualizerSessions(internal, audioSessionId);\n    }\n\n    public void openEqualizerSession(boolean internal, int audioSessionId) {\n        equalizer.openEqualizerSession(internal, audioSessionId);\n    }\n\n    public void updateEqualizer() {\n        equalizer.update();\n    }\n\n    void releaseWakelock() {\n        if (player != null) {\n            player.releaseWakelock();\n        }\n    }\n\n    private void setOpenFailedCounter(int openFailedCounter) {\n        this.openFailedCounter = openFailedCounter;\n    }\n\n    /**\n     * @param force true to force the player onto the track next, false otherwise.\n     * @return The next position to play.\n     */\n    private int getNextPosition(final boolean force) {\n        return queueManager.getNextPosition(force);\n    }\n\n    public void open(@NonNull List<Song> songs, int position) {\n        queueManager.open(songs, position, this::openCurrentAndNext);\n    }\n\n    private void openCurrent() {\n        openCurrentAndMaybeNext(false);\n    }\n\n    public void openCurrentAndNext() {\n        openCurrentAndMaybeNext(true);\n    }\n\n    private void openCurrentAndMaybeNext(boolean openNext) {\n        if (queueManager.getCurrentPlaylist().isEmpty() || queueManager.queuePosition < 0 || queueManager.queuePosition >= queueManager.getCurrentPlaylist().size()) {\n            return;\n        }\n\n        stop(false);\n\n        boolean shutdown = false;\n\n        while (true) {\n            if (queueManager.getCurrentSong() != null && open(queueManager.getCurrentSong())) {\n                break;\n            }\n            // If we get here then opening the file failed.\n            if (openFailedCounter++ < 10 && queueManager.getCurrentPlaylist().size() > 1) {\n                final int pos = getNextPosition(false);\n                if (pos < 0) {\n                    musicServiceCallbacks.scheduleDelayedShutdown();\n                    if (isSupposedToBePlaying) {\n                        isSupposedToBePlaying = false;\n                        notifyChange(InternalIntents.PLAY_STATE_CHANGED);\n                    }\n                    return;\n                }\n                queueManager.queuePosition = pos;\n                stop(false);\n                queueManager.queuePosition = pos;\n            } else {\n                openFailedCounter = 0;\n                shutdown = true;\n                break;\n            }\n        }\n        // Go to bookmark if needed\n        if (queueManager.getCurrentSong() != null && queueManager.getCurrentSong().isPodcast) {\n            long bookmark = queueManager.getCurrentSong().bookMark;\n            // Start playing a little bit before the bookmark,\n            // so it's easier to get back in to the narrative.\n            seekTo(bookmark - 5000);\n        }\n\n        if (shutdown) {\n            musicServiceCallbacks.scheduleDelayedShutdown();\n            if (isSupposedToBePlaying) {\n                isSupposedToBePlaying = false;\n                notifyChange(InternalIntents.PLAY_STATE_CHANGED);\n            }\n\n        }\n        if (openNext) {\n            setNextTrack();\n        }\n    }\n\n    public boolean open(@NonNull Song song) {\n        if (player != null) {\n            player.setDataSource(song.path);\n            if (player != null && player.isInitialized()) {\n                openFailedCounter = 0;\n                return true;\n            }\n        }\n\n        stop(true);\n        return false;\n    }\n\n    public void openFile(String path, @Nullable Action completion) {\n        if (path == null) {\n            return;\n        }\n\n        Uri uri = Uri.parse(path);\n        long id = -1;\n        try {\n            id = Long.valueOf(uri.getLastPathSegment());\n        } catch (NumberFormatException ignored) {\n        }\n\n        Predicate<Song> predicate;\n\n        long finalId = id;\n        if (finalId != -1 && (path.startsWith(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI.toString()) || path.startsWith(MediaStore.Files.getContentUri(\"external\").toString()))) {\n            predicate = song -> song.id == finalId;\n        } else {\n            if (uri != null && path.startsWith(\"content://\")) {\n                path = uri.getPath();\n            }\n            String finalPath = path;\n            predicate = song -> song.path.contains(finalPath);\n        }\n\n        disposables.add(DataManager.getInstance().getSongsObservable(predicate)\n                .firstOrError()\n                .subscribe(songs -> {\n                    if (!songs.isEmpty() && queueManager.getCurrentSong() != null) {\n                        open(queueManager.getCurrentSong());\n                        if (completion != null) {\n                            completion.run();\n                        }\n                    }\n                }, error -> LogUtils.logException(TAG, \"Error opening file\", error)));\n    }\n\n    public void setNextTrack() {\n        queueManager.nextPlayPos = getNextPosition(false);\n        if (queueManager.nextPlayPos >= 0\n                && !queueManager.getCurrentPlaylist().isEmpty()\n                && queueManager.nextPlayPos < queueManager.getCurrentPlaylist().size()) {\n            final Song nextSong = queueManager.getCurrentPlaylist().get(queueManager.nextPlayPos);\n            try {\n                if (player != null) {\n                    player.setNextDataSource(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + \"/\" + nextSong.id);\n                }\n            } catch (Exception e) {\n                Log.e(TAG, \"Error: \" + e.getMessage());\n                CrashlyticsCore.getInstance().log(\"setNextTrack() with id failed. error: \" + e.getLocalizedMessage());\n            }\n        } else {\n            try {\n                if (player != null) {\n                    player.setNextDataSource(null);\n                }\n            } catch (Exception e) {\n                Log.e(TAG, \"Error: \" + e.getMessage());\n                CrashlyticsCore.getInstance().log(\"setNextTrack() failed with null id. error: \" + e.getLocalizedMessage());\n            }\n        }\n    }\n\n    public void enqueue(List<Song> songs, int action) {\n        queueManager.enqueue(\n                songs,\n                action,\n                this::setNextTrack,\n                () -> {\n                    openCurrentAndNext();\n                    play();\n                });\n    }\n\n    public void saveState() {\n        if (player != null && player.isInitialized()) {\n            PlaybackSettingsManager.INSTANCE.setSeekPosition(player.getPosition());\n        }\n    }\n\n    void release() {\n        if (isPlaying() || pausedByTransientLossOfFocus || playerHandler.hasMessages(PlayerHandler.TRACK_ENDED)) {\n            return;\n        }\n\n        if (ShuttleUtils.hasOreo()) {\n            if (audioFocusRequest != null) {\n                audioManager.abandonAudioFocusRequest(audioFocusRequest);\n            }\n        } else {\n            audioManager.abandonAudioFocus(audioFocusListener);\n        }\n\n        mediaSessionManager.setActive(false);\n    }\n\n    public void destroy() {\n\n        disposables.clear();\n\n        chromecastManager.release();\n\n        mediaSessionManager.destroy();\n\n        // Release all MediaPlayer resources, including the native player and wakelocks\n        if (player != null) {\n            player.release();\n            player.releaseWakelock();\n            player = null;\n        }\n\n        // Remove the audio focus listener and lock screen controls\n        if (ShuttleUtils.hasOreo()) {\n            if (audioFocusRequest != null) {\n                audioManager.abandonAudioFocusRequest(audioFocusRequest);\n            }\n        } else {\n            audioManager.abandonAudioFocus(audioFocusListener);\n        }\n\n        playerHandler.removeCallbacksAndMessages(null);\n\n        equalizer.releaseEffects();\n        equalizer.closeEqualizerSessions(true, getAudioSessionId());\n\n        // Quit the thread so that anything that gets posted won't run\n        handlerThread.quitSafely();\n    }\n\n    public boolean recentlyPlayed() {\n        return isPlaying() || System.currentTimeMillis() - lastPlayedTime < 5 * 60 * 1000 /* 5 mins */;\n    }\n\n    public int getAudioSessionId() {\n        if (player != null) {\n            return player.getAudioSessionId();\n        } else {\n            return 0;\n        }\n    }\n\n    public void seekTo(long position) {\n        if (player != null && player.isInitialized()) {\n            if (position < 0) {\n                position = 0;\n            } else if (position > player.getDuration()) {\n                position = player.getDuration();\n            }\n\n            player.seekTo(position);\n\n            if (playbackLocation == PlaybackManager.PlaybackLocation.REMOTE) {\n                try {\n                    chromecastManager.castManager.seek((int) position);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n\n            notifyChange(InternalIntents.POSITION_CHANGED);\n        }\n    }\n\n    public long getSeekPosition() {\n        switch (playbackLocation) {\n            case PlaybackLocation.LOCAL: {\n                if (player != null) {\n                    return player.getPosition();\n                }\n                break;\n            }\n            case PlaybackLocation.REMOTE: {\n                try {\n                    return (int) chromecastManager.castManager.getCurrentMediaPosition();\n                } catch (Exception e) {\n                    Log.e(TAG, e.toString());\n                    if (player != null) {\n                        return player.getPosition();\n                    }\n                }\n\n                break;\n            }\n        }\n        return 0;\n    }\n\n\n    @PlaybackLocation\n    int getPlaybackLocation() {\n        return playbackLocation;\n    }\n\n    void setPlaybackLocation(@PlaybackLocation int playbackLocation) {\n        this.playbackLocation = playbackLocation;\n    }\n\n    public void pause() {\n        switch (playbackLocation) {\n            case PlaybackLocation.LOCAL: {\n                playerHandler.removeMessages(PlayerHandler.FADE_UP);\n                if (isSupposedToBePlaying) {\n                    equalizer.closeEqualizerSessions(false, getAudioSessionId());\n                    if (player != null) {\n                        player.pause();\n                    }\n                    setIsSupposedToBePlaying(false, true);\n                    notifyChange(InternalIntents.PLAY_STATE_CHANGED);\n                    saveBookmarkIfNeeded();\n                }\n                break;\n            }\n            case PlaybackLocation.REMOTE: {\n                try {\n                    if (player != null) {\n                        player.seekTo(chromecastManager.castManager.getCurrentMediaPosition());\n                    }\n                    chromecastManager.castManager.pause();\n                    playbackState = PlaybackState.PAUSED;\n                    musicServiceCallbacks.scheduleDelayedShutdown();\n                    isSupposedToBePlaying = false;\n                    notifyChange(InternalIntents.PLAY_STATE_CHANGED);\n                    saveBookmarkIfNeeded();\n                } catch (Exception e) {\n                    Log.e(TAG, e.toString());\n                }\n                break;\n            }\n        }\n    }\n\n    public boolean isPlaying() {\n        switch (playbackLocation) {\n            case PlaybackLocation.LOCAL: {\n                return isSupposedToBePlaying;\n            }\n            case PlaybackLocation.REMOTE: {\n                return playbackState == PlaybackState.PLAYING;\n            }\n        }\n\n        return false;\n    }\n\n    public void stop(boolean goToIdle) {\n        switch (playbackLocation) {\n            case PlaybackLocation.LOCAL: {\n                if (player != null && player.isInitialized()) {\n                    player.stop();\n                }\n                if (goToIdle) {\n                    setIsSupposedToBePlaying(false, false);\n                } else {\n                    musicServiceCallbacks.stopForegroundImpl(false, true);\n                }\n                break;\n            }\n            case PlaybackLocation.REMOTE: {\n                try {\n                    if (player != null && player.isInitialized()) {\n                        player.seekTo(chromecastManager.castManager.getCurrentMediaPosition());\n                        player.stop();\n                    }\n                    playbackState = PlaybackState.STOPPED;\n                } catch (Exception e) {\n                    Log.e(TAG, e.toString());\n                }\n                if (goToIdle) {\n                    if (ShuttleUtils.isUpgraded() && chromecastManager.castManager != null) {\n                        HttpServer.getInstance().stop();\n                    }\n                    setIsSupposedToBePlaying(false, false);\n                } else {\n                    musicServiceCallbacks.stopForegroundImpl(false, true);\n                }\n                break;\n            }\n        }\n    }\n\n    public void next(boolean force) {\n        notifyChange(InternalIntents.TRACK_ENDING);\n\n        if (queueManager.getCurrentPlaylist().size() == 0) {\n            musicServiceCallbacks.scheduleDelayedShutdown();\n            return;\n        }\n\n        final int pos = getNextPosition(force);\n        if (pos < 0) {\n            setIsSupposedToBePlaying(false, true);\n            return;\n        }\n\n        queueManager.queuePosition = pos;\n        saveBookmarkIfNeeded();\n        stop(false);\n        queueManager.queuePosition = pos;\n        openCurrentAndNext();\n        play();\n        notifyChange(InternalIntents.META_CHANGED);\n    }\n\n    public void previous() {\n        queueManager.previous();\n        stop(false);\n        openCurrent();\n        play();\n        notifyChange(InternalIntents.META_CHANGED);\n    }\n\n    /**\n     * Helper function to wrap the logic around isSupposedToBePlaying for consistency\n     *\n     * @param supposedToBePlaying to set isSupposedToBePlaying to\n     * @param notify              whether we want to fire PLAY_STATE_CHANGED event\n     */\n    void setIsSupposedToBePlaying(boolean supposedToBePlaying, boolean notify) {\n        if (isSupposedToBePlaying != supposedToBePlaying) {\n            isSupposedToBePlaying = supposedToBePlaying;\n\n            // Update lastPlayed time first and notify afterwards, as the notification listener method needs the up-to-date value\n            // for the recentlyPlayed() method to work\n            if (!isSupposedToBePlaying) {\n                musicServiceCallbacks.scheduleDelayedShutdown();\n                lastPlayedTime = System.currentTimeMillis();\n            }\n\n            if (notify) {\n                notifyChange(InternalIntents.PLAY_STATE_CHANGED);\n            }\n        }\n    }\n\n    public void play() {\n        int status;\n\n        if (ShuttleUtils.hasOreo()) {\n            AudioFocusRequest audioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)\n                    .setOnAudioFocusChangeListener(audioFocusListener)\n                    .setAudioAttributes(new AudioAttributes.Builder()\n                            .setUsage(AudioAttributes.USAGE_MEDIA)\n                            .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)\n                            .build())\n                    .build();\n            this.audioFocusRequest = audioFocusRequest;\n            status = audioManager.requestAudioFocus(audioFocusRequest);\n        } else {\n            status = audioManager.requestAudioFocus(audioFocusListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);\n        }\n\n        if (status != AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {\n            return;\n        }\n\n        if (playbackLocation == PlaybackLocation.LOCAL) {\n            if (SettingsManager.getInstance().getEqualizerEnabled()) {\n                //Shutdown any existing external audio sessions\n                equalizer.closeEqualizerSessions(false, getAudioSessionId());\n\n                //Start internal equalizer session (will only turn on if enabled)\n                equalizer.openEqualizerSession(true, getAudioSessionId());\n            } else {\n                equalizer.openEqualizerSession(false, getAudioSessionId());\n            }\n        }\n\n        mediaSessionManager.setActive(true);\n\n        switch (playbackLocation) {\n            case PlaybackLocation.LOCAL: {\n                if (player != null && player.isInitialized()) {\n                    // If we are at the end of the song, go to the next song first\n                    long duration = player.getDuration();\n                    if (queueManager.repeatMode != QueueManager.RepeatMode.ONE && duration > 2000 && player.getPosition() >= duration - 2000) {\n                        next(true);\n                    }\n                    player.start();\n                    // Make sure we fade in, in case a previous fadein was stopped because of another focus loss\n                    playerHandler.removeMessages(PlayerHandler.FADE_DOWN);\n                    playerHandler.sendEmptyMessage(PlayerHandler.FADE_UP);\n\n                    setIsSupposedToBePlaying(true, true);\n\n                    musicServiceCallbacks.cancelShutdown();\n                    musicServiceCallbacks.updateNotification();\n                } else if (queueManager.getCurrentPlaylist().size() == 0) {\n                    // This is mostly so that if you press 'play' on a bluetooth headset without ever having played anything before, it will still play something.\n                    if (queueManager.queueReloading) {\n                        playOnQueueLoad = true;\n                    } else {\n                        playAutoShuffleList();\n                    }\n                }\n                break;\n            }\n            case PlaybackLocation.REMOTE: {\n                // If we are at the end of the song, go to the next song first\n                long duration = player != null ? player.getDuration() : 0;\n\n                if (queueManager.repeatMode != QueueManager.RepeatMode.ONE && duration > 2000 && player.getPosition() >= duration - 2000) {\n                    next(true);\n                }\n\n                if (!isSupposedToBePlaying) {\n                    isSupposedToBePlaying = true;\n                    notifyChange(InternalIntents.PLAY_STATE_CHANGED);\n                }\n\n                musicServiceCallbacks.cancelShutdown();\n                musicServiceCallbacks.updateNotification();\n\n                switch (playbackState) {\n                    case PlaybackState.STOPPED: {\n                        try {\n                            if (queueManager.getCurrentSong() != null) {\n                                chromecastManager.castManager.checkConnectivity();\n                                chromecastManager.prepareChromeCastLoad(queueManager.getCurrentSong(), 0, true);\n                                playbackState = PlaybackState.PLAYING;\n                                musicServiceCallbacks.updateNotification();\n                            }\n                        } catch (TransientNetworkDisconnectionException | NoConnectionException e) {\n                            Log.e(TAG, \"Play() called & failed. State: Stopped \" + e.toString());\n                            playbackState = PlaybackState.STOPPED;\n                            musicServiceCallbacks.updateNotification();\n                        }\n                        break;\n                    }\n                    case PlaybackState.PAUSED: {\n                        try {\n                            chromecastManager.castManager.checkConnectivity();\n                            chromecastManager.castManager.play();\n                            playbackState = PlaybackState.PLAYING;\n                            musicServiceCallbacks.updateNotification();\n                        } catch (TransientNetworkDisconnectionException | NoConnectionException | CastException e) {\n                            Log.e(TAG, \"Play() called & failed. State: Paused \" + e.toString());\n                            playbackState = PlaybackState.PAUSED;\n                            musicServiceCallbacks.updateNotification();\n                        }\n                        break;\n                    }\n                }\n\n                if (queueManager.getCurrentPlaylist().size() == 0) {\n                    // This is mostly so that if you press 'play' on a bluetooth headset without every having played anything before, it will still play something.\n                    if (queueManager.queueReloading) {\n                        playOnQueueLoad = true;\n                    } else {\n                        playAutoShuffleList();\n                    }\n                }\n            }\n        }\n    }\n\n    private void saveBookmarkIfNeeded() {\n        try {\n            if (queueManager.getCurrentSong() != null) {\n                if (queueManager.getCurrentSong().isPodcast) {\n                    long pos = getSeekPosition();\n                    long bookmark = queueManager.getCurrentSong().bookMark;\n                    long duration = queueManager.getCurrentSong().duration;\n                    if ((pos < bookmark && (pos + 10000) > bookmark) || (pos > bookmark && (pos - 10000) < bookmark)) {\n                        // The existing bookmark is close to the current position, so don't update it.\n                        return;\n                    }\n                    if (pos < 15000 || (pos + 10000) > duration) {\n                        // If we're near the start or end, clear the bookmark\n                        pos = 0;\n                    }\n\n                    // Write 'pos' to the bookmark field\n                    ContentValues values = new ContentValues();\n                    values.put(MediaStore.Audio.Media.BOOKMARK, pos);\n                    Uri uri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, queueManager.getCurrentSong().id);\n                    if (uri != null) {\n                        context.getContentResolver().update(uri, values, null, null);\n                    }\n                }\n            }\n        } catch (SQLiteException ignored) {\n        }\n    }\n\n    void setPlaybackState(@PlaybackState int playbackState) {\n        this.playbackState = playbackState;\n    }\n\n    boolean getIsSupposedToBePlaying() {\n        return isSupposedToBePlaying;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/simplecity/amp_library/playback/PlaybackManager.java	(revision e0764bcc340e8fa6a5427d9224c7e5b3dc656f05)
+++ app/src/main/java/com/simplecity/amp_library/playback/PlaybackManager.java	(date 1525084733000)
@@ -16,24 +16,25 @@
 import android.support.annotation.Nullable;
 import android.support.v4.content.ContextCompat;
 import android.support.v4.media.session.MediaSessionCompat;
-import android.util.Log;
+
 import com.annimon.stream.function.Predicate;
-import com.crashlytics.android.core.CrashlyticsCore;
-import com.google.android.libraries.cast.companionlibrary.cast.exceptions.CastException;
-import com.google.android.libraries.cast.companionlibrary.cast.exceptions.NoConnectionException;
-import com.google.android.libraries.cast.companionlibrary.cast.exceptions.TransientNetworkDisconnectionException;
 import com.simplecity.amp_library.http.HttpServer;
 import com.simplecity.amp_library.model.Song;
 import com.simplecity.amp_library.playback.constants.InternalIntents;
 import com.simplecity.amp_library.playback.constants.PlayerHandler;
 import com.simplecity.amp_library.services.Equalizer;
-import com.simplecity.amp_library.utils.*;
+import com.simplecity.amp_library.utils.DataManager;
+import com.simplecity.amp_library.utils.LogUtils;
+import com.simplecity.amp_library.utils.SettingsManager;
+import com.simplecity.amp_library.utils.ShuttleUtils;
+import com.simplecity.amp_library.utils.SleepTimer;
+
+import java.util.List;
+
 import io.reactivex.disposables.CompositeDisposable;
 import io.reactivex.functions.Action;
 import io.reactivex.schedulers.Schedulers;
 
-import java.util.List;
-
 public class PlaybackManager {
 
     private static final String TAG = "PlaybackManager";
@@ -43,27 +44,16 @@
         int LOCAL = 1;
     }
 
-    @interface PlaybackState {
-        int PLAYING = 0;
-        int PAUSED = 1;
-        int STOPPED = 2;
-    }
-
     private Context context;
 
     private HandlerThread handlerThread;
 
     private QueueManager queueManager;
 
-    private ChromecastManager chromecastManager;
-
     private MediaSessionManager mediaSessionManager;
 
     private boolean playOnQueueLoad;
 
-    @PlaybackState
-    private int playbackState;
-
     private Equalizer equalizer;
 
     @PlaybackLocation
@@ -72,9 +62,6 @@
     @Nullable
     private AudioFocusRequest audioFocusRequest;
 
-    @Nullable
-    MultiPlayer player;
-
     private AudioManager audioManager;
 
     private int openFailedCounter = 0;
@@ -100,6 +87,10 @@
         }
     };
 
+    private LocalPlayback localPlayback;
+    private CastPlayback castPlayback;
+    private Playback currentPlayback = null;
+
     PlaybackManager(Context context, QueueManager queueManager, MusicService.Callbacks musicServiceCallbacks) {
 
         this.context = context.getApplicationContext();
@@ -110,8 +101,6 @@
 
         mediaSessionManager = new MediaSessionManager(context, queueManager, this, musicServiceCallbacks);
 
-        chromecastManager = new ChromecastManager(context, queueManager, this);
-
         // Start up the thread running the service. Note that we create a separate thread because the service normally runs in the process's
         // main thread, which we don't want to block. We also make it background priority so CPU-intensive work will not disrupt the UI.
         handlerThread = new HandlerThread("MusicPlayerHandler", android.os.Process.THREAD_PRIORITY_BACKGROUND);
@@ -119,16 +108,17 @@
 
         playerHandler = new MediaPlayerHandler(this, queueManager, handlerThread.getLooper());
 
-        playbackState = PlaybackState.STOPPED;
-
-        player = new MultiPlayer(context);
-        player.setHandler(playerHandler);
-
-        equalizer = new Equalizer(context);
-
         audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
 
+        localPlayback = new LocalPlayback(context);
+
+        ChromecastManager chromecastManager = new ChromecastManager(context, queueManager, this);
         chromecastManager.init();
+        castPlayback = new CastPlayback(chromecastManager, queueManager);
+
+        setPlaybackLocation(PlaybackLocation.LOCAL);
+
+        equalizer = new Equalizer(context);
 
         disposables.add(SleepTimer.getInstance().getCurrentTimeObservable()
                 .subscribe(remainingTime -> {
@@ -206,9 +196,7 @@
     }
 
     public void setVolume(float volume) {
-        if (player != null) {
-            player.setVolume(volume);
-        }
+        currentPlayback.setVolume(volume);
     }
 
     public void playAutoShuffleList() {
@@ -267,9 +255,7 @@
     }
 
     void releaseWakelock() {
-        if (player != null) {
-            player.releaseWakelock();
-        }
+        localPlayback.releaseWakeLock();
     }
 
     private void setOpenFailedCounter(int openFailedCounter) {
@@ -351,12 +337,9 @@
     }
 
     public boolean open(@NonNull Song song) {
-        if (player != null) {
-            player.setDataSource(song.path);
-            if (player != null && player.isInitialized()) {
-                openFailedCounter = 0;
-                return true;
-            }
+        if (currentPlayback.open(song.path)) {
+            openFailedCounter = 0;
+            return true;
         }
 
         stop(true);
@@ -406,23 +389,9 @@
                 && !queueManager.getCurrentPlaylist().isEmpty()
                 && queueManager.nextPlayPos < queueManager.getCurrentPlaylist().size()) {
             final Song nextSong = queueManager.getCurrentPlaylist().get(queueManager.nextPlayPos);
-            try {
-                if (player != null) {
-                    player.setNextDataSource(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + "/" + nextSong.id);
-                }
-            } catch (Exception e) {
-                Log.e(TAG, "Error: " + e.getMessage());
-                CrashlyticsCore.getInstance().log("setNextTrack() with id failed. error: " + e.getLocalizedMessage());
-            }
+            currentPlayback.setNextTrack(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + "/" + nextSong.id);
         } else {
-            try {
-                if (player != null) {
-                    player.setNextDataSource(null);
-                }
-            } catch (Exception e) {
-                Log.e(TAG, "Error: " + e.getMessage());
-                CrashlyticsCore.getInstance().log("setNextTrack() failed with null id. error: " + e.getLocalizedMessage());
-            }
+            currentPlayback.setNextTrack(null);
         }
     }
 
@@ -438,9 +407,7 @@
     }
 
     public void saveState() {
-        if (player != null && player.isInitialized()) {
-            PlaybackSettingsManager.INSTANCE.setSeekPosition(player.getPosition());
-        }
+        PlaybackSettingsManager.INSTANCE.setSeekPosition(currentPlayback.getPosition());
     }
 
     void release() {
@@ -463,18 +430,13 @@
 
         disposables.clear();
 
-        chromecastManager.release();
+        localPlayback.release();
+        castPlayback.release();
 
         mediaSessionManager.destroy();
 
-        // Release all MediaPlayer resources, including the native player and wakelocks
-        if (player != null) {
-            player.release();
-            player.releaseWakelock();
-            player = null;
-        }
-
         // Remove the audio focus listener and lock screen controls
+        // Todo: Can move AudioManager related tasks to a base LocalPlayback class
         if (ShuttleUtils.hasOreo()) {
             if (audioFocusRequest != null) {
                 audioManager.abandonAudioFocusRequest(audioFocusRequest);
@@ -497,59 +459,17 @@
     }
 
     public int getAudioSessionId() {
-        if (player != null) {
-            return player.getAudioSessionId();
-        } else {
-            return 0;
-        }
+        return currentPlayback.getAudioSessionId();
     }
 
     public void seekTo(long position) {
-        if (player != null && player.isInitialized()) {
-            if (position < 0) {
-                position = 0;
-            } else if (position > player.getDuration()) {
-                position = player.getDuration();
-            }
-
-            player.seekTo(position);
-
-            if (playbackLocation == PlaybackManager.PlaybackLocation.REMOTE) {
-                try {
-                    chromecastManager.castManager.seek((int) position);
-                } catch (Exception e) {
-                    e.printStackTrace();
-                }
-            }
-
-            notifyChange(InternalIntents.POSITION_CHANGED);
-        }
+        currentPlayback.seek(position);
+        notifyChange(InternalIntents.POSITION_CHANGED);
     }
 
     public long getSeekPosition() {
-        switch (playbackLocation) {
-            case PlaybackLocation.LOCAL: {
-                if (player != null) {
-                    return player.getPosition();
-                }
-                break;
-            }
-            case PlaybackLocation.REMOTE: {
-                try {
-                    return (int) chromecastManager.castManager.getCurrentMediaPosition();
-                } catch (Exception e) {
-                    Log.e(TAG, e.toString());
-                    if (player != null) {
-                        return player.getPosition();
-                    }
-                }
-
-                break;
-            }
-        }
-        return 0;
+        return currentPlayback.getPosition();
     }
-
 
     @PlaybackLocation
     int getPlaybackLocation() {
@@ -558,88 +478,40 @@
 
     void setPlaybackLocation(@PlaybackLocation int playbackLocation) {
         this.playbackLocation = playbackLocation;
-    }
-
-    public void pause() {
         switch (playbackLocation) {
-            case PlaybackLocation.LOCAL: {
-                playerHandler.removeMessages(PlayerHandler.FADE_UP);
-                if (isSupposedToBePlaying) {
-                    equalizer.closeEqualizerSessions(false, getAudioSessionId());
-                    if (player != null) {
-                        player.pause();
-                    }
-                    setIsSupposedToBePlaying(false, true);
-                    notifyChange(InternalIntents.PLAY_STATE_CHANGED);
-                    saveBookmarkIfNeeded();
-                }
-                break;
-            }
-            case PlaybackLocation.REMOTE: {
-                try {
-                    if (player != null) {
-                        player.seekTo(chromecastManager.castManager.getCurrentMediaPosition());
-                    }
-                    chromecastManager.castManager.pause();
-                    playbackState = PlaybackState.PAUSED;
-                    musicServiceCallbacks.scheduleDelayedShutdown();
-                    isSupposedToBePlaying = false;
-                    notifyChange(InternalIntents.PLAY_STATE_CHANGED);
-                    saveBookmarkIfNeeded();
-                } catch (Exception e) {
-                    Log.e(TAG, e.toString());
-                }
-                break;
-            }
-        }
+            case PlaybackLocation.LOCAL:
+                currentPlayback = localPlayback;
+                break;
+            case PlaybackLocation.REMOTE:
+                currentPlayback = castPlayback;
+                break;
+        }
+        currentPlayback.setCallbacks(playbackCallbacks);
+    }
+
+    public void pause() {
+        playerHandler.removeMessages(PlayerHandler.FADE_UP);
+        currentPlayback.pause();
+        equalizer.closeEqualizerSessions(false, getAudioSessionId());
+        setIsSupposedToBePlaying(false, true);
+        notifyChange(InternalIntents.PLAY_STATE_CHANGED);
+        saveBookmarkIfNeeded();
     }
 
     public boolean isPlaying() {
-        switch (playbackLocation) {
-            case PlaybackLocation.LOCAL: {
-                return isSupposedToBePlaying;
-            }
-            case PlaybackLocation.REMOTE: {
-                return playbackState == PlaybackState.PLAYING;
-            }
-        }
-
-        return false;
+        return currentPlayback.isPlaying();
     }
 
     public void stop(boolean goToIdle) {
-        switch (playbackLocation) {
-            case PlaybackLocation.LOCAL: {
-                if (player != null && player.isInitialized()) {
-                    player.stop();
-                }
-                if (goToIdle) {
-                    setIsSupposedToBePlaying(false, false);
-                } else {
-                    musicServiceCallbacks.stopForegroundImpl(false, true);
-                }
-                break;
-            }
-            case PlaybackLocation.REMOTE: {
-                try {
-                    if (player != null && player.isInitialized()) {
-                        player.seekTo(chromecastManager.castManager.getCurrentMediaPosition());
-                        player.stop();
-                    }
-                    playbackState = PlaybackState.STOPPED;
-                } catch (Exception e) {
-                    Log.e(TAG, e.toString());
-                }
-                if (goToIdle) {
-                    if (ShuttleUtils.isUpgraded() && chromecastManager.castManager != null) {
-                        HttpServer.getInstance().stop();
-                    }
-                    setIsSupposedToBePlaying(false, false);
-                } else {
-                    musicServiceCallbacks.stopForegroundImpl(false, true);
-                }
-                break;
-            }
+        currentPlayback.stop();
+
+        if (goToIdle) {
+            if (playbackLocation == PlaybackLocation.REMOTE) {
+                HttpServer.getInstance().stop();
+            }
+            setIsSupposedToBePlaying(false, false);
+        } else {
+            musicServiceCallbacks.stopForegroundImpl(false, true);
         }
     }
 
@@ -698,8 +570,19 @@
     }
 
     public void play() {
-        int status;
 
+        if (queueManager.getCurrentPlaylist().isEmpty()) {
+            // This is mostly so that if you press 'play' on a bluetooth headset without ever having played anything before, it will still play something.
+            if (queueManager.queueReloading) {
+                playOnQueueLoad = true;
+            } else {
+                playAutoShuffleList();
+            }
+            return;
+        }
+
+        // Todo: Can move AudioManager related tasks to a base LocalPlayback class
+        int response;
         if (ShuttleUtils.hasOreo()) {
             AudioFocusRequest audioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)
                     .setOnAudioFocusChangeListener(audioFocusListener)
@@ -709,113 +592,47 @@
                             .build())
                     .build();
             this.audioFocusRequest = audioFocusRequest;
-            status = audioManager.requestAudioFocus(audioFocusRequest);
+            response = audioManager.requestAudioFocus(audioFocusRequest);
         } else {
-            status = audioManager.requestAudioFocus(audioFocusListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);
+            response = audioManager.requestAudioFocus(audioFocusListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);
         }
 
-        if (status != AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
+        if (response != AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
             return;
         }
 
-        if (playbackLocation == PlaybackLocation.LOCAL) {
-            if (SettingsManager.getInstance().getEqualizerEnabled()) {
-                //Shutdown any existing external audio sessions
-                equalizer.closeEqualizerSessions(false, getAudioSessionId());
+        mediaSessionManager.setActive(true);
+
+        // Todo: Determining whether or not to move to the next track should happen before play() is called.
+        // If we are at the end of the song, go to the next song first
+        Song currentSong = queueManager.getCurrentSong();
+        if (currentSong != null) {
+            long duration = currentSong.duration;
+            if (queueManager.repeatMode != QueueManager.RepeatMode.ONE && duration > 2000 && currentPlayback.getPosition() >= duration - 2000) {
+                next(true);
+            }
+        }
+
+        if (SettingsManager.getInstance().getEqualizerEnabled()) {
+            //Shutdown any existing external audio sessions
+            equalizer.closeEqualizerSessions(false, getAudioSessionId());
 
-                //Start internal equalizer session (will only turn on if enabled)
-                equalizer.openEqualizerSession(true, getAudioSessionId());
-            } else {
-                equalizer.openEqualizerSession(false, getAudioSessionId());
-            }
+            //Start internal equalizer session (will only turn on if enabled)
+            equalizer.openEqualizerSession(true, getAudioSessionId());
+        } else {
+            equalizer.openEqualizerSession(false, getAudioSessionId());
         }
 
-        mediaSessionManager.setActive(true);
+        if (currentPlayback.play()) {
+            setIsSupposedToBePlaying(true, true);
+        }
 
-        switch (playbackLocation) {
-            case PlaybackLocation.LOCAL: {
-                if (player != null && player.isInitialized()) {
-                    // If we are at the end of the song, go to the next song first
-                    long duration = player.getDuration();
-                    if (queueManager.repeatMode != QueueManager.RepeatMode.ONE && duration > 2000 && player.getPosition() >= duration - 2000) {
-                        next(true);
-                    }
-                    player.start();
-                    // Make sure we fade in, in case a previous fadein was stopped because of another focus loss
-                    playerHandler.removeMessages(PlayerHandler.FADE_DOWN);
-                    playerHandler.sendEmptyMessage(PlayerHandler.FADE_UP);
+        // Make sure we fade in, in case a previous fadein was stopped because of another focus loss
+        playerHandler.removeMessages(PlayerHandler.FADE_DOWN);
+        playerHandler.sendEmptyMessage(PlayerHandler.FADE_UP);
 
-                    setIsSupposedToBePlaying(true, true);
-
-                    musicServiceCallbacks.cancelShutdown();
-                    musicServiceCallbacks.updateNotification();
-                } else if (queueManager.getCurrentPlaylist().size() == 0) {
-                    // This is mostly so that if you press 'play' on a bluetooth headset without ever having played anything before, it will still play something.
-                    if (queueManager.queueReloading) {
-                        playOnQueueLoad = true;
-                    } else {
-                        playAutoShuffleList();
-                    }
-                }
-                break;
-            }
-            case PlaybackLocation.REMOTE: {
-                // If we are at the end of the song, go to the next song first
-                long duration = player != null ? player.getDuration() : 0;
-
-                if (queueManager.repeatMode != QueueManager.RepeatMode.ONE && duration > 2000 && player.getPosition() >= duration - 2000) {
-                    next(true);
-                }
-
-                if (!isSupposedToBePlaying) {
-                    isSupposedToBePlaying = true;
-                    notifyChange(InternalIntents.PLAY_STATE_CHANGED);
-                }
-
-                musicServiceCallbacks.cancelShutdown();
-                musicServiceCallbacks.updateNotification();
-
-                switch (playbackState) {
-                    case PlaybackState.STOPPED: {
-                        try {
-                            if (queueManager.getCurrentSong() != null) {
-                                chromecastManager.castManager.checkConnectivity();
-                                chromecastManager.prepareChromeCastLoad(queueManager.getCurrentSong(), 0, true);
-                                playbackState = PlaybackState.PLAYING;
-                                musicServiceCallbacks.updateNotification();
-                            }
-                        } catch (TransientNetworkDisconnectionException | NoConnectionException e) {
-                            Log.e(TAG, "Play() called & failed. State: Stopped " + e.toString());
-                            playbackState = PlaybackState.STOPPED;
-                            musicServiceCallbacks.updateNotification();
-                        }
-                        break;
-                    }
-                    case PlaybackState.PAUSED: {
-                        try {
-                            chromecastManager.castManager.checkConnectivity();
-                            chromecastManager.castManager.play();
-                            playbackState = PlaybackState.PLAYING;
-                            musicServiceCallbacks.updateNotification();
-                        } catch (TransientNetworkDisconnectionException | NoConnectionException | CastException e) {
-                            Log.e(TAG, "Play() called & failed. State: Paused " + e.toString());
-                            playbackState = PlaybackState.PAUSED;
-                            musicServiceCallbacks.updateNotification();
-                        }
-                        break;
-                    }
-                }
-
-                if (queueManager.getCurrentPlaylist().size() == 0) {
-                    // This is mostly so that if you press 'play' on a bluetooth headset without every having played anything before, it will still play something.
-                    if (queueManager.queueReloading) {
-                        playOnQueueLoad = true;
-                    } else {
-                        playAutoShuffleList();
-                    }
-                }
-            }
-        }
+        musicServiceCallbacks.cancelShutdown();
+        musicServiceCallbacks.updateNotification();
     }
 
     private void saveBookmarkIfNeeded() {
@@ -847,11 +664,35 @@
         }
     }
 
-    void setPlaybackState(@PlaybackState int playbackState) {
-        this.playbackState = playbackState;
+    void setPlaybackState(@CastPlayback.PlaybackState int playbackState) {
+        castPlayback.setPlaybackState(playbackState);
     }
 
     boolean getIsSupposedToBePlaying() {
         return isSupposedToBePlaying;
     }
+
+    private Playback.Callbacks playbackCallbacks = new Playback.Callbacks() {
+        @Override
+        public void trackEnded(Playback playback) {
+            if (playback == localPlayback) {
+                playerHandler.sendEmptyMessage(PlayerHandler.TRACK_ENDED);
+                playerHandler.sendEmptyMessage(PlayerHandler.RELEASE_WAKELOCK);
+            }
+        }
+
+        @Override
+        public void trackWentToNext(Playback playback) {
+            if (playback == localPlayback) {
+                playerHandler.sendEmptyMessage(PlayerHandler.TRACK_WENT_TO_NEXT);
+            }
+        }
+
+        @Override
+        public void onError(Playback playback, String error) {
+            if (playback == localPlayback) {
+                playerHandler.sendMessageDelayed(playerHandler.obtainMessage(PlayerHandler.SERVER_DIED), 2000);
+            }
+        }
+    };
 }
